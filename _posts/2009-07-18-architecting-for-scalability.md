---
id: 47
title: Architecting for scalability and audit logs by explicitly modeling state transitions
date: 2009-07-18T22:38:54+00:00
author: David
layout: post
guid: http://davidleston.com/?p=47
permalink: /2009/07/architecting-for-scalability/
categories:
  - Programming
---
In his talk, **Unsleash Your Domain**, [Greg Young](http://codebetter.com/blogs/gregyoung/ "Greg Young's blog") presents a dense discussion of topics about which I am passionate. At its core, the talk is about how to guarantee a correct audit log and architect for scalability.

Before watching this talk, I suggest brushing up on the following terms if you're not already familiar with them: [domain model](http://en.wikipedia.org/wiki/Domain_model "Wikipedia article on domain model"), [aggregate root](http://www.lostechies.com/blogs/jimmy_bogard/archive/2008/05/20/entities-value-objects-aggregates-and-roots.aspx "Entities, Value Objects, Aggregates and Roots at LosTechies.com") and [ubiquitous language](http://domaindrivendesign.org/node/132). (In one system I work on, we use the words "session" and "ticket" to describe the same concept. Precise, consistent and accurate language leads to better communication and understanding.)

[Click here to watch the talk.](http://www.infoq.com/presentations/greg-young-unshackle-qcon08 "Greg Young's talk Unleash Your Domain")

Here are some valuable lessons I see in Greg's talk:

  * Software runs. It's about action. Most models I've seen focus on nouns, such as customer and order, and make actions, such as place order and cancel order, secondary concepts. A [functional design](http://en.wikipedia.org/wiki/Functional_design "Wikipedia article on functional software design") focuses the model on actions, not aggregate roots. Software with a focus on action makes testing and auditing, which are fundamentally about verifying action, natural.

  * Think of the state of an aggregate root as the result of a stream of events. As Greg mentioned, Martin Fowler dubbed this design [Event Sourcing](http://martinfowler.com/eaaDev/EventSourcing.html "Martin Fowler's article on Event Sourcing"). Distributed source control systems focus on changes to a file rather than versions of files. This subtle difference is a behind much of the value distributed source control systems offer. Greg talks about how building your state from a stream of events can result in the ability to rewind and playback history. To see how this might be visualized, check out [the playback feature of Google Wave, demonstrated at 49 minutes into this video](http://googleblog.blogspot.com/2009/05/went-walkabout-brought-back-google-wave.html).As a bonus, since [a stream is your data](http://en.wikipedia.org/wiki/Dataflow_programming "Wikipedial article on dataflow programming"), you can easily start writing [code in a functional style](http://en.wikipedia.org/wiki/Functional_programming "Wikipedia article on functional programming"), even in [Java](http://www.google.com/#q=functional+programming+java "How to program in Java in a functional style"). Sequences are the core interface to data for [Clojure](http://clojure.org/sequences "Clojure's sequences") and [LINQ](http://www.eggheadcafe.com/tutorials/aspnet/159e4793-6b17-4e89-bd94-3bde8a5f2d50/iterators-iterator-block.aspx "LINQ's iterators article by Jon Skeet").Also, Greg mentioned the the ability to use a [document database](http://en.wikipedia.org/wiki/Document-oriented_database "Wikipedia article on document-oriented databases"). These are the kinds of databases that power Google and Amazon.

  * Look for places to implement [eventual consistency](http://smoothspan.wordpress.com/2007/12/22/eventual-consistency-is-not-that-scary/ "Eventual Consistency Is Not That Scary"). Here's an example of an opportunity for eventual consistency:  You want to provide the ability to mark a blog post as a favorite. Here's a series of steps to implement eventual consistency: You have an application responsible for rendering the blog post and if it has already been marked as a favorite. User clicks "mark as favorite."  This triggers a call to a different application which accepts the command, validates it, inserts the command into a queue to update the read-only data stores and response to the client that the command has been accepted. The UI then displays the item has been marked as a favorite. If the user refreshes the page before all read-only data stores have been updated, then they may see the blog post as not marked as a favorite. As Greg would say, so what?  This is unlikely to happen and the consequences are small compared to scalability gained by making this operation asynchronous.

  * Greg talks about designing business processes as if they were to be done with paper: "[Paper was awesome because it never gave the impression of global consistency and it is the thinking that went into the optimization of paper processes that can help us optimize our transactional systems.](http://codebetter.com/blogs/gregyoung/archive/2008/05/18/dddd-12-how-long.aspx)"  I thought his restaurant example in the talk might not click with some viewers, so I'm expanding on it here. When you place an order at a restaurant, you've inserted a command in a queue. The waitress transfers the message from the queue she's holding to a queue for the kitchen. The kitchen then prepares your order and notifies the waitress of the event that the order is ready to be served. The kitchen may then decrement the inventory records. The waitress then picks up the order and serves it to you. The reason why this not a fully consistent state is that the cook knows about your order after you've placed it. The inventory is decremented after the food is cooked. It's eventually consistent. And it works.As a slight tangent, human processes are often automated because automation is thought to be the solution to poorly executed processes. Strive to first standardize processes before automation as the process is often ill-defined. Sometimes, simply defining a process cures problems. From [The Toyota Way Fieldbook](http://www.amazon.com/gp/product/0071448934?ie=UTF8&tag=davidleston-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0071448934 "The Toyota Way Fieldbook by Jeffrey Liker and David Meier - link to Amazon"): "Standardization is a key element of the Toyota system. A process that is not standardized is fraught with chaos, variation, and the associated problems of continually "riding the wave." According to Toyota, standardization is the baseline for continuous improvement, the time when real improvement begins and is measurable."

Related links:

  * [Domain-Driven Design: Tackling Complexity in the Heart of Software](http://www.amazon.com/gp/product/0321125215?ie=UTF8&tag=davidleston-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0321125215 "Domain-Driven Design: Tackling Complexity in the Heart of Software by Eric Evans - link to Amazon") by [Eric Evans](http://www.infoq.com/interviews/domain-driven-design-eric-evans "Interview with Eric Evans about domain-driven design")

  * [Bertrand Meyer](http://en.wikipedia.org/wiki/Bertrand_Meyer "Wikipedia article on Bertrand Meyer") talks about [command and query separation](http://martinfowler.com/bliki/CommandQuerySeparation.html "Martin Fowler's article on command and query separation") in his book [Object Oriented Software Construction](http://www.amazon.com/gp/product/0136291554?ie=UTF8&tag=davidleston-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0136291554 "Object Oriented Software Construction by Bertrand Meyer - link to Amazon").

  * [Bounded context](http://domaindrivendesign.org/node/91)
  * [Behavior Driven Development or BDD](http://behaviour-driven.org/)
  * [Given, When, Then](http://wiki.github.com/aslakhellesoy/cucumber/given-when-then)

"Man acts as though he were the shaper and master of language, while in fact language remains the master of man." &#8211;  [Martin Heidegger](http://en.wikipedia.org/wiki/Martin_Heidegger "Wikipedial article on Martin Heidegger, an influential German philosopher")

Update Sept 2, 2009: I received feedback that such an architecture is only for mission critical systems. In his talk, [Buy a Feature: An Adventure in Immutability and Actor](http://www.infoq.com/presentations/actors-scala-immutability-pollack "David Pollack's talk at InfoQ"), David Pollack, the creator of the [Lift web framework](http://liftweb.net/ "Lift web framework for Scala") for [Scala](http://en.wikipedia.org/wiki/Scala_%28programming_language%29 "Wikipedia article on the Scala language for the JVM"), talks about an application, [Buy a Feature](http://www.innovationgames.com/the-games/Buy+a+Feature "the seriously fun way to prioritize serious stuff"), which implements this architecture.